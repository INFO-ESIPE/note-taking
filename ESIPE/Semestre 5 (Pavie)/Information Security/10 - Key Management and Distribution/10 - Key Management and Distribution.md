[[Information Security]]
13/11/2024
****
**Note:** It might be asked to describe the [[10 - Key Management and Distribution#Symmetric Key Distribution Using Asymmetric Encryption|second protocol]] as the exam :)
****
**Table of Contents**
```table-of-contents
```

****
## Current concern

So far we have our decent ciphers, but we need a reliable way to exchange the keys and to ensure identity (of both the manager of the exchange system and the key holders).
	*Those ciphers are only reliable as long as the keys are owned by the correct people. If a secret key is leaked, everything that was done with it cannot be trusted anymore*

Major issue is that most of the exchanges are carried (or include in the chain) proxies or middle-men, which can be a problem for conventionality and integrity


****
## Symmetric Key Distribution Using Symmetric Encryption

Only the two parties must see and possess the key. They must be able to exchange the keys often (as we want to prevent cryptanalysts to collect too much data about our keys from available ciphertexts).
	*This is especially the case when you encrypt a huge amount of similar data (e.g., HTML documents as they share a similar structure, money transactions as they share the same structure besides the account holders and the amount of money ...)*

This last requirement actually reveals how important the **key distribution technique** is (delivering the key to the two parties only, which guarantees integrity and confidentiality)

Available solutions:
- A generates a key and **physically deliver** it to B
	*Moves from entity to entity instead of going through proxies, which is good. However, this is not very convenient and quick, especially to establish an end-to-end encryption over the network. If A wants to talk to a lot of people, he will have to exchange thousands of keys (one per remote machine), which seems infeasible physically. The **distribution method is bad for large-scale exchanges***

- A **trusted third party generates the key** and **physically deliver** it to both A and B
	*We must be sure that this proxy is trustworthy, which is an issue. Also, like the previous solution, physical distribution is bad when it involves a lot of people*

- If A and B have previously and recently used a key, one party can **transmit the new key** to the other, **encrypted using the old key**
	*If an adversary or a proxy gained access to the key, this method becomes unsafe as all the subsequently-generated keys are visible in cleartext*

- If A and B each has an encrypted connection to a **third party C**, C can **deliver a key on the encrypted links to A and B**
	*Again, C must be a trustworthy proxy, but this is the most widely-used method as it offers a good **symmetric distribution system**.*


As we can see, a lot of assumptions are made (the proxy is trustworthy, the last key was never leaked ...). 

Distributing symmetric keys via symmetric keys is relatively inconvenient, as it requires a master key for every pair of people we want to help in the exchange of key. Furthermore, a share authority solution is also dangerous, as it will end up storing all the master keys (the safe becomes pretty much like a treasure cave that every cryptanalyst or adversary will attempt to break into).


****
## Symmetric Key Distribution Using Asymmetric Encryption
==Most of what is there is still copy-paste, I will try to make it more personal in the upcoming days==

As we have seen so far, public-key encryption is way slower, which is why we mostly use it only to encrypt secret keys and distribute them (instead of encrypting long documents etc).
	*We encrypt a symmetric key via the private key of our asymmetric cipher*

We can follow the **Simple Secret Key Distribution**:
1. A generates a public/private key pair {`PUa`, `PRa`} and transmits a message to B consisting of `PUa` and an identifier of A (`IDA`).
2. B generates a secret key (`Ks`) and transmits it to A, which is encrypted with `PUa`.
3. A computes D(`PRa`, E(`PUa`, Ks)) to recover the secret key. Because only A can
decrypt the message, only A and B will know the identity of Ks.
4. A discards `PUa` and `PRa` and B discards `PUa`

This works but introduces some issues, including identity assumptions (A must trust B, and B must trust the identifier A forwards him), and a MITM vulnerability


Instead, we tend to use the following protocol (which is more complex but more reliable):
1. A uses B’s public key to encrypt a message to B containing an identifier of A(`IDA`) and a nonce (`N1`), which is used to identify this transaction uniquely
2. B sends a message to A encrypted with `PUa` and containing A’s nonce (`N1`) as well as a new nonce generated by B (`N2`). Because only B could have decrypted message (1), the presence of `N1` in message (2) assures A that the correspondent is B
3. A returns `N2`, encrypted using B’s public key, to assure B that its correspondent is A
4. A selects a secret key Ks and sends M = E(`PUb`, E(`PRa`, Ks)) to B. Encryption of this message with B’s public key ensures that only B can read it; encryption with A’s private key ensures that only A could have sent it
5. B computes D(`PUa`, D(`PRb`, M)) to recover the secret key

At the end, the two keypairs trust each other (as the nonces allows to authenticates each other), but this still does not guarantee us that we talk to the good entity (A thinks he talks to B, but what if B is pretending to be the correct entity)
	*The only statement we can do is: Owner of keypair A can trust and communicate with owner of keypair B.*

This solution is way better than relying on symmetric encryption like in the first chapter. However, we still need a way to publish our public keys to the world, so they can communicate with us and likewise ...


****
## Public key distribution

There are four ways of distributing public keys:
- Public Announcement
- Public Directory
- Public-key Authority
- Public-key Certificates (most widely used)


### Public Announcement

Each entity can broadcast his public key to the community at large (forums, mailing lists...)

**Convenient, but anyone can forge it**. One could pretend to be user A and send a public key to another participant, tricking him into believing it is really from user A. 
	*So, unless User A sees the trickery and alert users about it, the adversary can read everything that was supposed to be send to user A*


### Public Directory

Every owner of a keypair places his public key in a public directory that is trusted (managed by a directory authority that verified the sender's identity beforehand).
	*An authentication system (sign-in) works as well*

This looks like a simple array (key-value pairs):

| Owner   | Public key    |
| ------- | ------------- |
| goobert | 198ff81ab9... |
| forax   | 99edf9233...  |
| ...     | ...           |

This method is more secure than public announcement, but still introduces a risk if an adversary succeed in gaining access to the directory and change the keys.
	*This method does guarantee confidentiality, but not integrity as there is still a scenario where it's possible for someone to replace the keys and perform a MITM attack...*

A second issue is that most of those directories are owned by governments (or large companies that have to comply with the government's orders and country's laws). If the government asks this company to change the keys (for espionage or manipulation/psyop purposes), they can do it. Same problem as the one above...

Last issue we might encounter is that it can quickly become a bottleneck, as everyone will turn to the directory each time they have to acquire a public key (heavy traffic).
	*This one is only performance-related, but it's still important to have a blazing fast system instead of a slow peace of crap*


****
14/11/2024

### Public-key Authority

This time, the authority sets up a **master key** for each participant, and encrypts the participant's public keys with it. **Only the participant knows the authority's public key, and the authority keeps it's private keys (one per participant public key to store) confidential**

Unless the master keys are compromised, it is impossible for an adversary to modify a record, or adding fake keys to the collection. Unlike the aforementioned methods, keys are now **signed**.


### Public-key Certificates

A certificate is just a file provided to us by a complex structure called the **Public Key Infrastructure (PKI)**, more details [[10 - Key Management and Distribution#Public-key Infrastructure|here]].
This document contains both a public key and the identity of its owner, signed by a trustworthy authority (CA)'s private key.


****
## X.509 Certificates

X.509 Certificates are the most widely-used schemes of public-key certificates.
	*Used in most network security applications (TLS, IPSec, S/MIME)*



****
## Public-key Infrastructure

